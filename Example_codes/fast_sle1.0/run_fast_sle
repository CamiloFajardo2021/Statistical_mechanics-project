
##########################################################################
#    This file is part of fast_sle (version 1.0), which implements 
#    a fast algorithm for simulating the Schramm-Loewner evolution (SLE)  
#
#    Copyright (C) 2005 Tom Kennedy
#
#    fast_sle is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    fast_sle is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with fast_sle; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    E-mail contact: tgk@math.arizona.edu
#    Ordinary mail: 
#	Tom Kennedy
#        Mathematics Department
#	University of Arizona
#	Tucson, ZA 85721, USA
#
##########################################################################

# file: run_fast_sle
# 
# script for showing how to run driver_sle.c
# The script compiles the program and runs it.
# The parameters like kappa, number of steps in the discretization,...
# are set in this script and may be changed here. 
# Documentation on these parameters follows. 

# The program driver_sle.c writes the coordinates of the points on the SLE 
# trace to the file "sle.plt"

# 'kappa' is the usual SLE parameter
kappa=2.666667

# 'nsteps' is the number of points to be computed on the SLE trace
nsteps=4000

# 'dsteps' is the number of time intervals in between the points computed 
# on the SLE trace
dsteps=5

# Present code can use two different conformal maps to approximate the SLE.
# map_choice=1: vertical slit, shifted from the origin. The shift
#  depends on kappa.
# map_choice=2: tilted slit starting at the origin with the angle 
#  depending on kappa.
map_choice=2

# Time may be discretized in two ways.
# dt_choice=1: Uniform time intervals
# dt_choice=2: non-uniform time intervals
dt_choice=2

# There are two choices for the spatial increments in the approximation 
# to the Brownian motion.
# dx_choice=1: Bernoulli
# dx_choice=2: Gaussian
dx_choice=2

# The program can either use the fast algorithm which uses Laurent series
# or do an "exact" computation. The results should be very close. 
# This can be used to compare how much error the Laurent series approximation
# is introducing and also to compare timings
# laurent_flag=0 is "exact" but slow computation
# laurent_flag=1 is fast computation using Laurent series
laurent_flag=1

# The following three parameters control just how the Laurent series 
# approximation is used. 

nblock=20
nterms=10
laurent_factor=3.

# seed for the random number generator. 
seed=0

rm driver_sle
make driver_sle

rm junk.in

echo ''$kappa'' >> junk.in
echo ''$nsteps'' >> junk.in
echo ''$dsteps'' >> junk.in

echo ''$map_choice'' >> junk.in
echo ''$dt_choice'' >> junk.in
echo ''$dx_choice'' >> junk.in

echo ''$laurent_flag'' >> junk.in

echo ''$nblock'' >> junk.in
echo ''$nterms'' >> junk.in
echo ''$laurent_factor'' >> junk.in

echo ''$seed'' >> junk.in

time ./driver_sle < junk.in 


